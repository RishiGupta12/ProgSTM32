/* 
 * Copyright (C) 2018, Rishi Gupta. All rights reserved.
 */

package flash.stm32.uart;

import java.io.IOException;

import com.serialpundit.serial.SerialComManager;
import com.serialpundit.serial.SerialComManager.BAUDRATE;
import com.serialpundit.serial.SerialComManager.DATABITS;
import com.serialpundit.serial.SerialComManager.FLOWCONTROL;
import com.serialpundit.serial.SerialComManager.PARITY;
import com.serialpundit.serial.SerialComManager.STOPBITS;

import flash.stm32.uart.internal.SystemProperties;

public final class UARTCMDExecutor {
	
    /**<p>Production release version of this UART STM32 flasher sdk. </p>*/
    public static final String UART_LIB_VERSION = "1.0";
    
    /** <p>Pre-defined enum constants for baud rates supported by STM32 bootloader. </p>*/
    public enum BR { 
        B1200(1200), B1800(1800), B2400(2400), B4800(4800), B9600(9600), B14400(14400), B19200(19200), 
        B28800(28800), B38400(38400), B56000(56000), B57600(57600), B115200(115200);
        private int value;
        private BR(int value) {
            this.value = value;	
        }
        public int getValue() {
            return this.value;
        }
    }
    
    /** <p>Pre-defined enum constants for number of data bits in a given serial frame. </p>*/
    public enum DB {
        /** <p>Serial frame will contain 5 data bits. </p>*/
        DB5(5),
        /** <p>Serial frame will contain 6 data bits. </p>*/
        DB6(6),
        /** <p>Serial frame will contain 7 data bits. </p>*/
        DB7(7),
        /** <p>Serial frame will contain 8 data bits. </p>*/
        DB8(8);
        private int value;
        private DB(int value) {
            this.value = value;	
        }
        public int getValue() {
            return this.value;
        }
    }
    
    /** <p>Pre-defined enum constants for number of stop bits in a given serial frame. </p>*/
    public enum SB {
        /** <p>Number of stop bits in one frame is 1. </p>*/
        SB1(1),
        /** <p>Number of stop bits in one frame is 1.5. </p>*/
        SB15(4),
        /** <p>Number of stop bits in one frame is 2. </p>*/
        SB2(2);
        private int value;
        private SB(int value) {
            this.value = value;	
        }
        public int getValue() {
            return this.value;
        }
    }
    
    /** <p>Pre-defined enum constants for enabling type of parity in a serial frame. </p>*/
    public enum PRTY {
        /** The uart frame does not contain any parity bit. Errors are handled by application for example 
         * using CRC algorithm.*/
        NONE(1),
        /** <p>The number of bits in the frame with the value one is odd. If the sum of bits 
         * with a value of 1 is odd in the frame, the parity bit's value is set to zero. 
         * If the sum of bits with a value of 1 is even in the frame, the parity bit value 
         * is set to 1, making the total count of 1's in the frame an odd number. </p>*/
        ODD(2),
        /** <p>The number of bits in the frame with the value one is even. The number 
         * of bits whose value is 1 in a frame is counted. If that total is odd, 
         * the parity bit value is set to 1, making the total count of 1's in the frame 
         * an even number. If the count of ones in a frame a is already even, 
         * the parity bit's value remains 0. </p>
         * <p>Odd parity may be more fruitful since it ensures that at least one state 
         * transition occurs in each character, which makes it more reliable as compared 
         * even parity. </p>
         * <p>Even parity is a special case of a cyclic redundancy check (CRC), 
         * where the 1-bit CRC is generated by the polynomial x+1.</p>*/
       EVEN(3),
        /** <p>The parity bit is set to the mark signal condition (logical 1). An application
         * may use the 9th (parity) bit for some form of addressing or special signaling. 
         * The mark parity is also known as stick parity.</p>*/
        MARK(4),
        /** <p>The parity bit is set to the space signal condition (logical 0). The mark 
         * and space parity is uncommon, as it adds no error detection information. The space parity 
         * is also known as stick parity.</p>*/
        SPACE(5);
        private int value;
        private PRTY(int value) {
            this.value = value;	
        }
        public int getValue() {
            return this.value;
        }
    }
	
    /** <p>Pre-defined enum constants for controlling data flow between DTE and DCE or two serial devices.</p>*/
    public enum FLOWCTRL {
        /** <p>No flow control; application is responsible to manage data buffers. Application can 
         * assert or de-assert RTS/CTS or DTR/DSR signals explicitly. </p>*/
        NONE(1),
        /** <p>Operating system (or driver) will assert or de-assert RTS/CTS lines as per the amount of 
         * data in input buffers. </p>*/
        RTS_CTS(2),
        /** <p>Operating system (or driver) will assert or de-assert DTR/DSR lines as per the amount of 
         * data in input buffers. </p>*/
        DTR_DSR(3),
        /** <p>Operating system (or driver) will send XON or XOFF characters as per the amount of data 
         * in input buffers. Upon reception of XOFF system will stop transmitting data and vice-versa. </p>*/
        XON_XOFF(4);
        private int value;
        private FLOWCTRL(int value) {
            this.value = value;	
        }
        public int getValue() {
            return this.value;
        }
    }
    
    private long comPortHandle;
    private final SerialComManager scm;
    private final SystemProperties sprop;
    
    public UARTCMDExecutor() throws IOException {
    	
    	sprop = new SystemProperties();
    	String tmpDir = sprop.getJavaIOTmpDir();
    	
    	scm = new SerialComManager("stmuartfwqkj", tmpDir, true, false);
    	
    }
    
    public void openComPort( ) {
    	
    }
    


}
